const { createCsvDataSource } = require('./csvDataSource');
const commandHandlers = require('./tmCommandHandlers');

class TmAiEngine {
Â  constructor({ dataSource, defaultUserTimezone = 'UTC' }) {
Â  Â  this.dataSource = dataSource;
Â  Â  this.defaultUserTimezone = defaultUserTimezone;

Â  Â  this.responseTemplates = new Map();
Â  Â  this.templatesLoaded = false;
Â  }

Â  static async create(opts) {
Â  Â  const engine = new TmAiEngine(opts);
Â  Â  await engine.loadTemplates();
Â  Â  return engine;
Â  }

Â  async loadTemplates() {
Â  Â  this.responseTemplates.set('show_schedule', {
Â  Â  Â  found: 'I found {count} show{plural}:\n\n{details}',
Â  Â  Â  notFound: 'No shows matched your criteria.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing the show schedule right now.',
Â  Â  });
Â  Â  this.responseTemplates.set('venue_info', {
Â  Â  Â  found: 'Hereâ€™s the venue info for {venue_name}:\n\n{details}',
Â  Â  Â  notFound: 'I couldnâ€™t find information about that venue.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing venue information right now.',
Â  Â  });
Â  Â  this.responseTemplates.set('setlist', {
Â  Â  Â  found: 'ðŸŽµ Setlist for {show_name}:\n\n{songs}',
Â  Â  Â  notFound: 'The setlist hasnâ€™t been finalized yet.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing setlist information.',
Â  Â  });
Â  Â  this.responseTemplates.set('travel_info', {
Â  Â  Â  found: 'âœˆï¸ Travel Information:\n\n{details}',
Â  Â  Â  notFound: 'No travel information available.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing travel details right now.',
Â  Â  });
Â  Â  this.responseTemplates.set('soundcheck', {
Â  Â  Â  found: 'ðŸ”Š Schedule:\n\n{details}',
Â  Â  Â  notFound: 'No soundcheck schedule available.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing the schedule right now.',
Â  Â  });
Â  Â  this.responseTemplates.set('production_notes', {
Â  Â  Â  found: 'ðŸ“‹ Production Notes for {header}:\n\n{details}',
Â  Â  Â  multiClarify: 'There are multiple matching shows in {city}: {dates}. Which show did you mean? (You can reply â€œall of themâ€.)',
Â  Â  Â  notFound: 'No production notes found for that show.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing production notes right now.',
Â  Â  });
Â  Â  this.responseTemplates.set('merch_sales', {
Â  Â  Â  found: 'ðŸ§¾ Merch Sales for {header}:\n\n{details}',
Â  Â  Â  multiClarify: 'There are multiple matching shows in {city}: {dates}. Which show did you mean? (You can reply â€œall of themâ€.)',
Â  Â  Â  notFound: 'No recorded merch sales for that show.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing merch sales right now.',
Â  Â  });
Â  Â  this.responseTemplates.set('flight_info', {
Â  Â  Â  found: 'âœˆï¸ Flights to {city}:\n\n{details}',
Â  Â  Â  askTz: 'For flight times, do you want airport local time, your local time, or both?',
Â  Â  Â  notFound: 'No upcoming flights found to {city}.',
Â  Â  Â  error: 'Iâ€™m having trouble accessing flight information right now.',
Â  Â  });
Â  Â  this.templatesLoaded = true;
Â  }
Â  async generateResponse(params) {
Â  Â  const { message, intent, context, member } = params;
Â  Â  const _coerced = this.coerceFollowupIntent(message, intent, context);
Â  Â  if (_coerced) { intent = _coerced; console.log('[engine] followup->', intent.intent_type); }
Â  Â  console.log('[DEBUG][engine] intent=', intent?.intent_type, 'entities=', intent?.entities);

Â  Â  if (!this.templatesLoaded) {
Â  Â  Â  await this.loadTemplates();
Â  Â  }

Â  Â  if (!intent || !intent.intent_type) {
Â  Â  Â  return this.generateGeneralResponse(message, context, member);
Â  Â  }

Â  Â  try {
Â  Â  Â  const intentType = intent.intent_type;

Â  Â  Â  switch (intentType) {
Â  Â  Â  Â  case 'show_schedule':
Â  Â  Â  Â  Â  return await this.handleShowSchedule(intent, member);

Â  Â  Â  Â  case 'venue_info':
Â  Â  Â  Â  Â  return await this.handleVenueInfo(intent, member);

Â  Â  Â  Â  case 'setlist':
Â  Â  Â  Â  Â  return await this.handleSetlist(intent, member);

Â  Â  Â  Â  case 'travel_info':
Â  Â  Â  Â  Â  return await this.handleTravelInfo(intent, member);

Â  Â  Â  Â  case 'soundcheck':
Â  Â  Â  Â  Â  return await this.handleSoundcheck(intent, member);

Â  Â  Â  Â  case 'production_notes':
Â  Â  Â  Â  Â  return await this.handleProductionNotes(message, intent, member);

Â  Â  Â  Â  case 'merch_sales':
Â  Â  Â  Â  Â  return await this.handleMerchSales(message, intent, member);

Â  Â  Â  Â  case 'flight_info':
Â  Â  Â  Â  Â  return await this.handleFlightInfo(message, intent, member);

Â  Â  Â  Â  case 'production_info':
Â  Â  Â  Â  case 'amenities_info':
Â  Â  Â  Â  case 'personnel':
Â  Â  Â  Â  case 'access':
Â  Â  Â  Â  case 'media_info':
Â  Â  Â  Â  case 'merch_logistics':
Â  Â  Â  Â  Â  return { content: commandHandlers[intentType](message, intent, member) };

Â  Â  Â  Â  case 'help':
Â  Â  Â  Â  Â  return { content: commandHandlers.help() };
        
Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  return this.generateFallbackResponse(message, intent);
Â  Â  Â  }
Â  Â  } catch (err) {
Â  Â  Â  return {
Â  Â  Â  Â  content: 'Iâ€™m sorry, I hit a snag processing that. Please try again in a moment.',
Â  Â  Â  Â  metadata: { error: String(err?.message || err), engine: 'tm-ai' },
Â  Â  Â  };
Â  Â  }
Â  }
Â  coerceFollowupIntent(message, intent, context) {
Â  Â  const txt = String(message || '').toLowerCase().trim();
Â  Â  const wantsAll = /(all of them|all shows|allb|bothb|every one|every show)b/.test(txt);
Â  Â  const last = context && context.lastPrompt;
Â  Â  if (wantsAll && last && last.intent === 'merch_sales' && last.multi_match && last.city) {
Â  Â  Â  return { intent_type: 'merch_sales', entities: { city: last.city, all: true } };
Â  Â  }
Â  Â  return null;
Â  }
Â  async handleProductionNotes(message, intent, member) {
Â  Â  const tpl = this.responseTemplates.get('production_notes');
Â  Â  try {
Â  Â  Â  const showId = intent.entities?.showId || intent.entities?.show_id;
Â  Â  Â  const city = intent.entities?.city;
Â  Â  Â  if (showId && !city) {
Â  Â  Â  Â  const rows = await this.dataSource.getProductionNotes(showId);
Â  Â  Â  Â  const details = this.formatProductionNotes(rows);
Â  Â  Â  Â  if (!details) {
Â  Â  Â  Â  Â  return { content: tpl.notFound, metadata: { intent: 'production_notes', show_id: showId } };
Â  Â  Â  Â  }
Â  Â  Â  Â  const header = `Show ${showId}`;
Â  Â  Â  Â  return { content: tpl.found.replace('{header}', header).replace('{details}', details), metadata: { intent: 'production_notes', show_id: showId } };
Â  Â  Â  }
Â  Â  Â  if (!city) {
Â  Â  Â  Â  return this.generateClarification('production notes', 'city or show ID');
Â  Â  Â  }
Â  Â  Â  const { shows } = await this.dataSource.getShows({ city });
Â  Â  Â  const list = Array.isArray(shows) ? shows : [];
Â  Â  Â  if (list.length === 0) {
Â  Â  Â  Â  return { content: 'I couldnâ€™t find any shows for that city.', metadata: { intent: 'production_notes', city } };
Â  Â  Â  }
Â  Â  Â  const allWanted = this.detectAllPhrase(message);
Â  Â  Â  if (list.length > 1 && !allWanted) {
Â  Â  Â  Â  const dates = list.map(s => this.formatDateDisplay(s.date, s.timezone || s.venue_timezone)).join(', ');
Â  Â  Â  Â  const clarify = (tpl.multiClarify || 'There are multiple shows in {city}: {dates}. Which show did you mean? (You can reply â€œall of themâ€.)')
Â  Â  Â  Â  Â  .replace('{city}', city)
Â  Â  Â  Â  Â  .replace('{dates}', dates);
Â  Â  Â  Â  return { content: clarify, metadata: { intent: 'production_notes', city, multi_match: true, options: list.map(s => ({ show_id: s.show_id, date: s.date })) } };
Â  Â  Â  }
Â  Â  Â  const target = allWanted ? list : [list[0]];
Â  Â  Â  const blocks = [];
Â  Â  Â  for (const s of target) {
Â  Â  Â  Â  const rows = await this.dataSource.getProductionNotes(s.show_id);
Â  Â  Â  Â  const details = this.formatProductionNotes(rows);
Â  Â  Â  Â  const header = `${city} â€” ${this.formatDateDisplay(s.date, s.timezone || s.venue_timezone)}`;
Â  Â  Â  Â  blocks.push(details ? `**${header}**\n${details}` : `**${header}**\n(No production notes recorded.)`);
Â  Â  Â  }
Â  Â  Â  return {
Â  Â  Â  Â  content: blocks.join('\n\n'),
Â  Â  Â  Â  metadata: { intent: 'production_notes', city, count: target.length, all: allWanted },
Â  Â  Â  Â  entities: { city, count: target.length }
Â  Â  Â  };
Â  Â  } catch (err) {
Â  Â  Â  console.error('[ERROR][production_notes]', err);
Â  Â  Â  return { content: tpl.error, metadata: { error: String(err?.message || err), intent: 'production_notes' } };
Â  Â  }
Â  }

Â  async handleMerchSales(message, intent, member) {
Â  Â  const tpl = this.responseTemplates.get('merch_sales');
Â  Â  try {
Â  Â  Â  const showId = intent.entities?.showId || intent.entities?.show_id;
Â  Â  Â  const city = intent.entities?.city;

Â  Â  Â  if (showId && !city) {
Â  Â  Â  Â  console.log("[DEBUG][merch_sales] fetching rows for showId=", showId);
Â  Â  Â  Â  let rows = await this.dataSource.getMerchSales(showId);
Â  Â  Â  Â  if ((rows == null || rows.length === 0) && typeof showId === "string" && showId.startsWith("#")) {
Â  Â  Â  Â  Â  rows = await this.dataSource.getMerchSales(showId.slice(1));
Â  Â  Â  Â  }
Â  Â  Â  Â  const arr = Array.isArray(rows) ? rows : (rows && rows.items) || [];
Â  Â  Â  Â  const details = this.formatMerchSales(arr, member);
Â  Â  Â  Â  if (!details) {
Â  Â  Â  Â  Â  return { content: tpl.notFound, metadata: { intent: 'merch_sales', show_id: showId } };
Â  Â  Â  Â  }
Â  Â  Â  Â  const header = `Show ${showId}`;
Â  Â  Â  Â  return { content: tpl.found.replace('{header}', header).replace('{details}', details), metadata: { intent: 'merch_sales', show_id: showId } };
Â  Â  Â  }

Â  Â  Â  if (!city) {
Â  Â  Â  Â  return this.generateClarification('merch sales', 'city or show ID');
Â  Â  Â  }

Â  Â  Â  const { shows } = await this.dataSource.getShows({ city });
Â  Â  Â  const list = Array.isArray(shows) ? shows : [];
Â  Â  Â  if (list.length === 0) {
Â  Â  Â  Â  return { content: 'I couldnâ€™t find any shows for that city.', metadata: { intent: 'merch_sales', city } };
Â  Â  Â  }

Â  Â  Â  // Decide on multi-match behaviour: last show vs total sales
Â  Â  Â  const wantsLast = /\b(last|latest|most recent)\b/i.test(message);
Â  Â  Â  const wantsTotal = /\b(total|cumulative|overall|sum|all sales)\b/i.test(message);

Â  Â  Â  // Sort shows chronologically by (date, then time if present)
Â  Â  Â  const sorted = [...list].sort((a, b) => {
Â  Â  Â  Â  const ad = String(a.date || '');
Â  Â  Â  Â  const at = String(a.show_time || a.time || '');
Â  Â  Â  Â  const bd = String(b.date || '');
Â  Â  Â  Â  const bt = String(b.show_time || b.time || '');
Â  Â  Â  Â  return (ad + at).localeCompare(bd + bt);
Â  Â  Â  });

Â  Â  Â  if (list.length > 1) {
Â  Â  Â  Â  if (wantsLast) {
Â  Â  Â  Â  Â  const lastShow = sorted[sorted.length - 1];
Â  Â  Â  Â  Â  let rows = await this.dataSource.getMerchSales(lastShow.show_id);
Â  Â  Â  Â  Â  if ((!rows || rows.length === 0) && typeof lastShow.show_id === "string" && lastShow.show_id.startsWith("#")) {
Â  Â  Â  Â  Â  Â  rows = await this.dataSource.getMerchSales(lastShow.show_id.slice(1));
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  const arr = Array.isArray(rows) ? rows : (rows && rows.items) || [];
Â  Â  Â  Â  Â  const details = this.formatMerchSales(arr, member);
Â  Â  Â  Â  Â  const header = `${city} â€” Last show (${this.formatDateDisplay(lastShow.date, lastShow.timezone || lastShow.venue_timezone)})`;
Â  Â  Â  Â  Â  return { content: details ? `**${header}**\n${details}` : `**${header}**\n(No merch sales recorded.)`,
Â Â  Â  Â  Â  Â  Â  Â  Â  Â  metadata: { intent: 'merch_sales', city, choice: 'last' } };
Â  Â  Â  Â  }

Â  Â  Â  Â  if (wantsTotal) {
Â  Â  Â  Â  Â  const agg = new Map();
Â  Â  Â  Â  Â  for (const s of sorted) {
Â  Â  Â  Â  Â  Â  let rows = await this.dataSource.getMerchSales(s.show_id);
Â  Â  Â  Â  Â  Â  if ((!rows || rows.length === 0) && typeof s.show_id === "string" && s.show_id.startsWith("#")) {
Â  Â  Â  Â  Â  Â  Â  rows = await this.dataSource.getMerchSales(s.show_id.slice(1));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const arr = Array.isArray(rows) ? rows : (rows && rows.items) || [];
Â  Â  Â  Â  Â  Â  for (const r of arr) {
Â  Â  Â  Â  Â  Â  Â  const key = String(r.item || 'Unknown');
Â  Â  Â  Â  Â  Â  Â  const prev = agg.get(key) || { item: key, quantity_sold: 0, price: '', gross_sales: 0 };
Â  Â  Â  Â  Â  Â  Â  prev.quantity_sold += Number(r.quantity_sold || 0);
Â  Â  Â  Â  Â  Â  Â  prev.gross_sales += Number(r.gross_sales || 0);
Â  Â  Â  Â  Â  Â  Â  agg.set(key, prev);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  const combined = Array.from(agg.values()).map(x => ({ ...x, gross_sales: Number(x.gross_sales).toFixed(2) }));
Â  Â  Â  Â  Â  const details = this.formatMerchSales(combined, member);
Â  Â  Â  Â  Â  const header = `${city} â€” Total sales across ${list.length} shows`;
Â  Â  Â  Â  Â  return { content: details ? `**${header}**\n${details}` : `**${header}**\n(No merch sales recorded.)`,
Â Â  Â  Â  Â  Â  Â  Â  Â  Â  metadata: { intent: 'merch_sales', city, choice: 'total', shows: list.length } };
Â  Â  Â  Â  }

Â  Â  Â  Â  const dates = sorted.map(s => this.formatDateDisplay(s.date, s.timezone || s.venue_timezone)).join(', ');
Â  Â  Â  Â  const clarify = `There are multiple shows in ${city}: ${dates}. Would you like the last show or total sales for all ${city} shows?`;
Â  Â  Â  Â  return { content: clarify, metadata: { intent: 'merch_sales', city, multi_match: true, prompt: 'last_or_total' } };
Â  Â  Â  }

Â  Â  Â  const s = list[0];
Â  Â  Â  let rows = await this.dataSource.getMerchSales(s.show_id);
Â  Â  Â  if ((!rows || rows.length === 0) && typeof s.show_id === "string" && s.show_id.startsWith("#")) {
Â  Â  Â  Â  rows = await this.dataSource.getMerchSales(s.show_id.slice(1));
Â  Â  Â  }
Â  Â  Â  const arr = Array.isArray(rows) ? rows : (rows && rows.items) || [];
Â  Â  Â  const details = this.formatMerchSales(arr, member);
Â  Â  Â  const header = `${city} â€” ${this.formatDateDisplay(s.date, s.timezone || s.venue_timezone)}`;
Â  Â  Â  return { content: details ? `**${header}**\n${details}` : `**${header}**\n(No merch sales recorded.)`,
Â Â  Â  Â  Â  Â  Â  Â  metadata: { intent: 'merch_sales', city, choice: 'single' } };
Â  Â  } catch (err) {
Â  Â  Â  console.error('[ERROR][merch_sales]', err);
Â  Â  Â  return { content: tpl.error, metadata: { error: String(err?.message || err), intent: 'merch_sales' } };
Â  Â  }
Â  }
Â  async handleHelp(message, intent, member) {
Â  Â  const list = [
Â  Â  Â  "Show schedule:",
Â  Â  Â  "â€¢ what shows are coming?",
Â  Â  Â  "â€¢ what shows are in sydney?",
Â  Â  Â  "â€¢ what's on 1 sep 2025?",
Â  Â  Â  "",
Â  Â  Â  "Soundcheck:",
Â  Â  Â  "â€¢ when is soundcheck for #605001?",
Â  Â  Â  "â€¢ soundcheck in melbourne?",
Â  Â  Â  "",
Â  Â  Â  "Production notes:",
Â  Â  Â  "â€¢ what are the production notes for #605001?",
Â  Â  Â  "â€¢ production notes for sydney?",
Â  Â  Â  "",
Â  Â  Â  "Flights (destination required):",
Â  Â  Â  "â€¢ when do we fly to singapore?",
Â  Â  Â  "â€¢ flights to auckland?",
Â  Â  Â  "",
Â  Â  Â  "Meta:",
Â  Â  Â  "â€¢ help",
Â  Â  Â  "â€¢ what can i ask you?"
Â  Â  ].join("\\n");
Â  Â  return { content: "**You can ask me things like:**\\n\\n" + list, metadata: { intent: "help" } };
Â  }

Â  async handleFlightInfo(message, intent, member) {
Â  Â  const tpl = this.responseTemplates.get('flight_info');
Â  Â  try {
Â  Â  Â  const city = intent.entities?.city;
Â  Â  Â  if (!city) {
Â  Â  Â  Â  return this.generateClarification('flight info', 'destination city');
Â  Â  Â  }

Â  Â  Â  // Timezone preference must be explicit for flights
Â  Â  Â  const pref = member?.flight_time_pref || null; // 'venue' | 'user_local' | 'both' | 'ask_each_time'
Â  Â  Â  if (!pref || pref === 'ask_each_time') {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  content: tpl.askTz,
Â  Â  Â  Â  Â  metadata: { intent: 'flight_info', needs_preference: 'flight_time_pref', city }
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // Fetch flights to destination (csvDataSource returns { flights: [...] })
Â  Â  Â  const data = await this.dataSource.getFlightsByDestination(city);
Â  Â  Â  const list = Array.isArray(data?.flights) ? data.flights : (Array.isArray(data) ? data : []);
Â  Â  Â  if (list.length === 0) {
Â  Â  Â  Â  return { content: tpl.notFound.replace('{city}', city), metadata: { intent: 'flight_info', city } };
Â  Â  Â  }

Â  Â  Â  // Sort by date, then by departure_time
Â  Â  Â  list.sort((a, b) => {
Â  Â  Â  Â  const ad = String(a.date || '');
Â  Â  Â  Â  const bd = String(b.date || '');
Â  Â  Â  Â  if (ad !== bd) return ad < bd ? -1 : 1;
Â  Â  Â  Â  const at = a.departure_time || '';
Â  Â  Â  Â  const bt = b.departure_time || '';
Â  Â  Â  Â  return at < bt ? -1 : at > bt ? 1 : 0;
Â  Â  Â  });

Â  Â  Â  const userTz = member?.user_timezone || this.defaultUserTimezone;
Â  Â  Â  const lines = list.map(f => {
Â  Â  Â  Â  const dep = this.formatTimeDisplay(f.departure_time, f.departure_timezone, pref, userTz, true);
Â  Â  Â  Â  const arr = this.formatTimeDisplay(f.arrival_time, f.arrival_timezone, pref, userTz, true);
Â  Â  Â  Â  const head = `${f.airline || ''} ${f.flight_number || ''}`.trim();
Â  Â  Â  Â  const conf = f.confirmation ? ` Â· Conf: ${f.confirmation}` : '';
Â  Â  Â  Â  return `${head}
${f.departure_city} â†’ ${f.arrival_city}
Departs: ${dep}
Arrives: ${arr}${conf}`;
Â  Â  Â  }).join('\n\n');

Â  Â  Â  const header = (tpl.foundHeader || `âœˆï¸ Flights to ${city}:\n\n`);
Â  Â  Â  return {
Â  Â  Â  Â  content: `${header}${lines}`,
Â  Â  Â  Â  metadata: { intent: 'flight_info', city, count: list.length }
Â  Â  Â  };
Â  Â  } catch (err) {
Â  Â  Â  return { content: tpl.error, metadata: { error: String(err?.message || err), intent: 'flight_info' } };
Â  Â  }
Â  }

Â  formatShowLine(index, show, member) {
Â  Â  const dateStr = this.formatDateDisplay(show.date, show.timezone || show.venue_timezone);
Â  Â  const locStr = [show.venue_name, show.city, show.state || show.country]
Â  Â  Â  .filter(Boolean)
Â  Â  Â  .join(', ');

Â  Â  const lineParts = [];
Â  Â  lineParts.push(`${index + 1}. ${dateStr}`);
Â  Â  lineParts.push(` Â  ðŸ“ ${locStr}`);

Â  Â  // Doors/Show times (TZ-aware) + role specifics
Â  Â  const tzPref = member?.timezone_preference || 'venue';
Â  Â  const userTz = member?.user_timezone || this.defaultUserTimezone;

Â  Â  if (show.doors_time) {
Â  Â  Â  lineParts.push(
Â  Â  Â  Â  ` Â  ðŸšª Doors: ${this.formatTimeDisplay(show.doors_time, show.timezone, tzPref, userTz)}`
Â  Â  Â  );
Â  Â  }
Â  Â  if (show.show_time) {
Â  Â  Â  lineParts.push(
Â  Â  Â  Â  ` Â  ðŸŽ« Show: ${this.formatTimeDisplay(show.show_time, show.timezone, tzPref, userTz)}`
Â  Â  Â  );
Â  Â  }
Â  Â  if (member?.role && (member.role === 'musician' || member.role === 'manager')) {
Â  Â  Â  if (show.soundcheck_time) {
Â  Â  Â  Â  lineParts.push(
Â  Â  Â  Â  Â  ` Â  ðŸ”Š Soundcheck: ${this.formatTimeDisplay(show.soundcheck_time, show.timezone, tzPref, userTz)}`
Â  Â  Â  Â  );
Â  Â  Â  }
Â  Â  Â  if (show.load_in_time) {
Â  Â  Â  Â  lineParts.push(
Â  Â  Â  Â  Â  ` Â  ðŸ“¦ Load-in: ${this.formatTimeDisplay(show.load_in_time, show.timezone, tzPref, userTz)}`
Â  Â  Â  Â  );
Â  Â  Â  }
Â  Â  }

Â  Â  if (show.ticket_status) {
Â  Â  Â  lineParts.push(` Â  ðŸŽŸï¸ ${show.ticket_status}`);
Â  Â  }

Â  Â  return lineParts.join('\n');
Â  }

Â  formatVenueDetails(v, member) {
Â  Â  const out = [];

Â  Â  out.push(`ðŸ“ ${v.name || 'Venue'}`);
Â  Â  if (v.address) {
Â  Â  Â  const addr = [v.address.street, v.address.city, v.address.state, v.address.zip]
Â  Â  Â  Â  .filter(Boolean)
Â  Â  Â  Â  .join(', ');
Â  Â  Â  out.push(`Address: ${addr}`);
Â  Â  }
Â  Â  if (v.capacity) out.push(`Capacity: ${Number(v.capacity).toLocaleString()}`);
Â  Â  if (v.phone) out.push(`Phone: ${v.phone}`);
Â  Â  if (v.website) out.push(`Website: ${v.website}`);

Â  Â  const role = member?.role || 'crew';
Â  Â  if (role === 'musician' || role === 'crew') {
Â  Â  Â  if (v.parking_info) out.push(`Parking: ${v.parking_info}`);
Â  Â  Â  if (v.load_in_info) out.push(`Load-in: ${v.load_in_info}`);
Â  Â  }
Â  Â  if (role === 'manager' || role === 'tour_manager') {
Â  Â  Â  if (v.contact) {
Â  Â  Â  Â  const contact = [v.contact.name, v.contact.email, v.contact.phone].filter(Boolean).join(' Â· ');
Â  Â  Â  Â  if (contact) out.push(`Contact: ${contact}`);
Â  Â  Â  }
Â  Â  }

Â  Â  return out.join('\n');
Â  }

Â  formatSetlist(data, member) {
Â  Â  const role = member?.role || 'crew';
Â  Â  if (Array.isArray(data?.sets) && data.sets.length) {
Â  Â  Â  const blocks = data.sets.map((set, idx) => {
Â  Â  Â  Â  const title = set.name || `Set ${idx + 1}`;
Â  Â  Â  Â  const songs = (set.songs || [])
Â  Â  Â  Â  Â  .map((song, i) => {
Â  Â  Â  Â  Â  Â  const parts = [`${i + 1}. ${song.title}`];
Â  Â  Â  Â  Â  Â  if (song.duration) parts.push(`(${song.duration})`);
Â  Â  Â  Â  Â  Â  if (song.notes && role === 'musician') parts.push(`- ${song.notes}`);
Â  Â  Â  Â  Â  Â  return parts.join(' ');
Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  .join('\n');
Â  Â  Â  Â  return `**${title}**\n${songs}`;
Â  Â  Â  });
Â  Â  Â  const total = data.total_duration ? `\n\nTotal runtime: ${data.total_duration}` : '';
Â  Â  Â  return `${blocks.join('\n\n')}${total}`.trim();
Â  Â  }

Â  Â  if (Array.isArray(data?.songs) && data.songs.length) {
Â  Â  Â  const list = data.songs
Â  Â  Â  Â  .map((song, i) => {
Â  Â  Â  Â  Â  const parts = [`${i + 1}. ${song.title}`];
Â  Â  Â  Â  Â  if (song.duration) parts.push(`(${song.duration})`);
Â  Â  Â  Â  Â  return parts.join(' ');
Â  Â  Â  Â  })
Â  Â  Â  Â  .join('\n');
Â  Â  Â  const total = data.total_duration ? `\n\nTotal runtime: ${data.total_duration}` : '';
Â  Â  Â  return `${list}${total}`.trim();
Â  Â  }

Â  Â  return '';
Â  }

Â  formatTravelInfo(info, member) {
Â  Â  const out = [];
Â  Â  const role = member?.role || 'crew';
Â  Â  const tzPref = member?.timezone_preference || 'venue';
Â  Â  const userTz = member?.user_timezone || this.defaultUserTimezone;

Â  Â  if (Array.isArray(info?.flights) && info.flights.length) {
Â  Â  Â  out.push('**Flights:**');
Â  Â  Â  for (const f of info.flights) {
Â  Â  Â  Â  out.push(`${f.airline || ''} ${f.flight_number || ''}`.trim());
Â  Â  Â  Â  out.push(`${f.departure_city} â†’ ${f.arrival_city}`);
Â  Â  Â  Â  // Times: if ISO timestamps provided, convert; else print raw
Â  Â  Â  Â  if (f.departure_time) {
Â  Â  Â  Â  Â  out.push(`Departs: ${this.formatTimeDisplay(f.departure_time, f.departure_timezone || info.timezone, tzPref, userTz, true)}`);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (f.arrival_time) {
Â  Â  Â  Â  Â  out.push(`Arrives: ${this.formatTimeDisplay(f.arrival_time, f.arrival_timezone || info.timezone, tzPref, userTz, true)}`);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (f.confirmation && role !== 'crew') {
Â  Â  Â  Â  Â  out.push(`Confirmation: ${f.confirmation}`);
Â  Â  Â  Â  }
Â  Â  Â  Â  out.push(''); // blank line
Â  Â  Â  }
Â  Â  }

Â  Â  if (info?.hotel) {
Â  Â  Â  out.push('**Hotel:**');
Â  Â  Â  out.push(`${info.hotel.name}`);
Â  Â  Â  if (info.hotel.address) out.push(`${info.hotel.address}`);
Â  Â  Â  if (info.hotel.check_in_date) out.push(`Check-in: ${this.formatDateDisplay(info.hotel.check_in_date, info.timezone)}`);
Â  Â  Â  if (info.hotel.check_out_date) out.push(`Check-out: ${this.formatDateDisplay(info.hotel.check_out_date, info.timezone)}`);
Â  Â  Â  if (info.hotel.confirmation && role !== 'crew') out.push(`Confirmation: ${info.hotel.confirmation}`);
Â  Â  Â  out.push('');
Â  Â  }

Â  Â  if (info?.ground_transport) {
Â  Â  Â  out.push('**Ground Transportation:**');
Â  Â  Â  out.push(`${info.ground_transport.type}`);
Â  Â  Â  if (info.ground_transport.pickup_time) {
Â  Â  Â  Â  const pickup = this.formatTimeDisplay(
Â  Â  Â  Â  Â  info.ground_transport.pickup_time,
Â  Â  Â  Â  Â  info.timezone,
Â  Â  Â  Â  Â  member?.timezone_preference || 'venue',
Â  Â  Â  Â  Â  member?.user_timezone || this.defaultUserTimezone,
Â  Â  Â  Â  Â  true
Â  Â  Â  Â  );
Â  Â  Â  Â  out.push(`Pickup: ${pickup} at ${info.ground_transport.pickup_location || 'TBD'}`);
Â  Â  Â  }
Â  Â  }

Â  Â  return out.join('\n').trim();
Â  }

Â  formatSoundcheckInfo(data, _member) {
Â  Â  const out = [];
Â  Â  const tzPref = _member?.timezone_preference || 'venue';
Â  Â  const userTz = _member?.user_timezone || this.defaultUserTimezone;
Â  Â  const venueTz = data?.timezone;

Â  Â  if (Array.isArray(data?.schedule) && data.schedule.length) {
Â  Â  Â  for (const item of data.schedule) {
Â  Â  Â  Â  const time = item.time
Â  Â  Â  Â  Â  ? this.formatTimeDisplay(item.time, venueTz, tzPref, userTz, true)
Â  Â  Â  Â  Â  : 'TBD';
Â  Â  Â  Â  out.push(`${time} - ${item.activity}`);
Â  Â  Â  Â  if (item.notes) out.push(` Â  ${item.notes}`);
Â  Â  Â  }
Â  Â  }

Â  Â  if (data?.technical_notes && (_member?.role === 'musician' || _member?.role === 'crew')) {
Â  Â  Â  out.push(`\n**Technical Notes:**\n${data.technical_notes}`);
Â  Â  }

Â  Â  return out.join('\n').trim();
Â  }

Â  // NEW formatters

Â  formatProductionNotes(rows) {
Â  Â  // rows: [{ show_id, category, note, priority, created_by }, ...]
Â  Â  if (!Array.isArray(rows) || rows.length === 0) return '';
Â  Â  // Group by category
Â  Â  const byCat = new Map();
Â  Â  for (const r of rows) {
Â  Â  Â  const cat = (r.category || 'General').trim();
Â  Â  Â  if (!byCat.has(cat)) byCat.set(cat, []);
Â  Â  Â  byCat.get(cat).push(r);
Â  Â  }
Â  Â  const badge = (p) => {
Â  Â  Â  const v = String(p || '').toLowerCase();
Â  Â  Â  if (v.startsWith('h')) return 'ðŸ”´ High';
Â  Â  Â  if (v.startsWith('m')) return 'ðŸŸ  Medium';
Â  Â  Â  if (v.startsWith('l')) return 'ðŸŸ¢ Low';
Â  Â  Â  return '';
Â  Â  };

Â  Â  const blocks = [];
Â  Â  for (const [cat, items] of byCat.entries()) {
Â  Â  Â  const lines = items.map(i => {
Â  Â  Â  Â  const b = badge(i.priority);
Â  Â  Â  Â  const who = i.created_by ? ` â€” ${i.created_by}` : '';
Â  Â  Â  Â  return `â€¢ ${i.note || ''}${b ? ` (${b})` : ''}${who}`;
Â  Â  Â  });
Â  Â  Â  blocks.push(`**${cat}**\n${lines.join('\n')}`);
Â  Â  }
Â  Â  return blocks.join('\n\n').trim();
Â  }

Â  formatMerchSales(rows, member) {
Â  Â  // rows: [{ show_id, item, quantity_sold, price, gross_sales }, ...]
Â  Â  if (!Array.isArray(rows) || rows.length === 0) return '';
Â  Â  const fmtNum = (n) => {
Â  Â  Â  const v = Number(n);
Â  Â  Â  return Number.isFinite(v) ? v.toLocaleString(member?.number_locale || 'en-US') : String(n || '');
Â  Â  };

Â  Â  let totalQty = 0;
Â  Â  let totalGross = 0;
Â  Â  const lines = rows.map(r => {
Â  Â  Â  const qty = Number(r.quantity_sold) || 0;
Â  Â  Â  const price = Number(r.price);
Â  Â  Â  const gross = Number(r.gross_sales);
Â  Â  Â  totalQty += qty;
Â  Â  Â  if (Number.isFinite(gross)) totalGross += gross;
Â  Â  Â  const priceStr = Number.isFinite(price) ? price.toFixed(2) : String(r.price || '');
Â  Â  Â  const grossStr = Number.isFinite(gross) ? gross.toFixed(2) : String(r.gross_sales || '');
Â  Â  Â  return `â€¢ ${r.item || 'Item'} â€” Qty: ${fmtNum(qty)} Â· Price: ${priceStr} Â· Gross: ${grossStr}`;
Â  Â  });

Â  Â  const totals = `\n**Totals:** Qty ${fmtNum(totalQty)} Â· Gross ${totalGross.toFixed(2)}`;
Â  Â  return lines.join('\n') + totals;
Â  }

Â  formatFlightList(flights, member) {
Â  Â  // flights: [{ date, airline, flight_number, departure_city, arrival_city,
Â  Â  // Â  Â  Â  Â  Â  departure_time, arrival_time, departure_timezone, arrival_timezone, confirmation, show_id }, ...]
Â  Â  const pref = member?.flight_time_pref || 'venue'; // note: handler ensures pref is chosen (not defaulted) before calling this
Â  Â  const userTz = member?.user_timezone || this.defaultUserTimezone;

Â  Â  const blockFor = (f) => {
Â  Â  Â  const head = `${(f.airline || '').trim()} ${(f.flight_number || '').trim()}`.trim();
Â  Â  Â  const route = `${f.departure_city} â†’ ${f.arrival_city}`;

Â  Â  Â  const dep = f.departure_time
Â  Â  Â  Â  ? this.formatTimeDisplay(f.departure_time, f.departure_timezone, pref, userTz, true)
Â  Â  Â  Â  : 'TBD';
Â  Â  Â  const arr = f.arrival_time
Â  Â  Â  Â  ? this.formatTimeDisplay(f.arrival_time, f.arrival_timezone, pref, userTz, true)
Â  Â  Â  Â  : 'TBD';

Â  Â  Â  const parts = [];
Â  Â  Â  parts.push(head || 'Flight');
Â  Â  Â  if (f.date) parts.push(this.formatDateDisplay(f.date));
Â  Â  Â  parts.push(route);
Â  Â  Â  parts.push(`Departs: ${dep}`);
Â  Â  Â  parts.push(`Arrives: ${arr}`);
Â  Â  Â  if (f.confirmation && member?.role && (member.role === 'manager' || member.role === 'tour_manager')) {
Â  Â  Â  Â  parts.push(`Confirmation: ${f.confirmation}`);
Â  Â  Â  }
Â  Â  Â  return parts.join('\n');
Â  Â  };

Â  Â  return flights.map(blockFor).join('\n\n');
Â  }

Â  // ===== Utilities =====

Â  buildShowFilters(entities = {}) {
Â  Â  const filters = {};
Â  Â  if (entities.city) filters.city = entities.city;
Â  Â  if (entities.upcoming) filters.upcoming = true;
Â  Â  if (entities.past) filters.past = true;
Â  Â  if (entities.date_from) filters.date_from = entities.date_from;
Â  Â  if (entities.date_to) filters.date_to = entities.date_to;
Â  Â  return filters;
Â  }

Â  formatDateDisplay(dateIsoOrYmd, timeZone) {
Â  Â  // Accept "YYYY-MM-DD" or full ISO; display as Weekday, Month Day, Year (TZ label if provided)
Â  Â  const d = new Date(dateIsoOrYmd);
Â  Â  if (Number.isNaN(d.getTime())) return String(dateIsoOrYmd);

Â  Â  const opts = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
Â  Â  if (timeZone) opts.timeZone = timeZone;

Â  Â  const main = new Intl.DateTimeFormat('en-US', opts).format(d);
Â  Â  return main;
Â  }

Â  /**
Â Â  * Format a time value according to user preference.
Â Â  * @param {string} isoOrLocal - ISO8601 timestamp (preferred) OR "YYYY-MM-DD HH:MM" OR "HH:MM"
Â Â  * @param {string} venueTimeZone - IANA TZ (e.g., "America/New_York" or airport TZ)
Â Â  * @param {'venue'|'user_local'|'both'} preference
Â Â  * @param {string} userTimeZone - IANA TZ for user
Â Â  * @param {boolean} includeDate - include date when formatting (for travel/schedules)
Â Â  */
Â  formatTimeDisplay(isoOrLocal, venueTimeZone, preference = 'venue', userTimeZone = 'UTC', includeDate = false) {
Â  Â  // Strategy:
Â  Â  // - If value is ISO (contains 'T' and timezone info), treat as exact instant and format in TZs.
Â  Â  // - Else, treat as local time in venue TZ without conversion (label with TZ). (Safer for CSV "HH:MM")
Â  Â  const isLikelyISO = /T/.test(isoOrLocal) && /Z|[+\-]\d{2}:\d{2}$/.test(isoOrLocal);
Â  Â  const fmOpts = includeDate
Â  Â  Â  ? { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }
Â  Â  Â  : { hour: 'numeric', minute: '2-digit' };

Â  Â  if (isLikelyISO) {
Â  Â  Â  const dt = new Date(isoOrLocal);
Â  Â  Â  if (Number.isNaN(dt.getTime())) return String(isoOrLocal);

Â  Â  Â  const venueStr = new Intl.DateTimeFormat('en-US', { ...fmOpts, timeZone: venueTimeZone }).format(dt);
Â  Â  Â  const userStr = new Intl.DateTimeFormat('en-US', { ...fmOpts, timeZone: userTimeZone }).format(dt);
Â  Â  Â  if (preference === 'venue') return `${venueStr} ${this.tzAbbr(venueTimeZone, dt)}`;
Â  Â  Â  if (preference === 'user_local') return `${userStr}`;
Â  Â  Â  return `${venueStr} ${this.tzAbbr(venueTimeZone, dt)} (${userStr} your time)`;
Â  Â  }

Â  Â  // Non-ISO (naive) â†’ print as-is with TZ label if venue TZ known
Â  Â  const label = venueTimeZone ? ` ${this.tzAbbr(venueTimeZone)}` : '';
Â  Â  if (preference === 'venue' || preference === 'both') return `${isoOrLocal}${label}`;
Â  Â  // user_local without a true instant â†’ we canâ€™t reliably convert; show raw
Â  Â  return `${isoOrLocal}`;
Â  }

Â  tzAbbr(timeZone, when = new Date()) {
Â  Â  try {
Â  Â  Â  // Extract short name like "EST" / "PDT"
Â  Â  Â  const parts = new Intl.DateTimeFormat('en-US', {
Â  Â  Â  Â  timeZone,
Â  Â  Â  Â  timeZoneName: 'short',
Â  Â  Â  Â  hour: '2-digit',
Â  Â  Â  }).formatToParts(when);
Â  Â  Â  const tz = parts.find((p) => p.type === 'timeZoneName')?.value;
Â  Â  Â  return tz ? tz.replace(/^GMT([+\-]\d+)?$/, 'GMT$1') : '';
Â  Â  } catch {
Â  Â  Â  return '';
Â  Â  }
Â  }

Â  extractResponseEntitiesFromShowList(shows) {
Â  Â  const first = shows[0] || {};
Â  Â  return {
Â  Â  Â  date: first.date,
Â  Â  Â  city: first.city,
Â  Â  Â  venue_id: first.venue_id,
Â  Â  };
Â  }

Â  extractResponseEntitiesFromVenue(v) {
Â  Â  return { venue_id: v.venue_id || v.id, city: v?.address?.city };
Â  }

Â  extractResponseEntitiesFromSetlist(d) {
Â  Â  return { show_id: d?.show_id, date: d?.date };
Â  }

Â  extractResponseEntitiesFromTravel(info) {
Â  Â  return { date: info?.date || undefined, show_id: info?.show_id || undefined };
Â  }

Â  extractResponseEntitiesFromSoundcheck(data) {
Â  Â  return { show_id: data?.show_id, date: data?.date };
Â  }

Â  // ===== Generic responses =====

Â  async generateGeneralResponse(message, _context, member) {
Â  Â  const lower = (message || '').toLowerCase();
Â  Â  const greetings = ['hello', 'hi', 'hey', 'good morning', 'good afternoon', 'good evening'];

Â  Â  if (greetings.some((g) => lower.includes(g))) {
Â  Â  Â  const name = member?.full_name || member?.username || 'there';
Â  Â  Â  return {
Â  Â  Â  Â  content: `Hey ${name}! I can help with shows, venues, setlists, travel, and schedules. What do you need?`,
Â  Â  Â  Â  metadata: { type: 'greeting' },
Â  Â  Â  };
Â  Â  }
Â  Â  if (lower.includes('thank')) {
Â  Â  Â  return {
Â  Â  Â  Â  content: 'Youâ€™re welcome! Need anything else?',
Â  Â  Â  Â  metadata: { type: 'thanks' },
Â  Â  Â  };
Â  Â  }
Â  Â  return {
Â  Â  Â  content:
Â  Â  Â  Â  'I can help you with show schedules, venue info, setlists, travel details, and soundcheck times. What would you like to know?',
Â  Â  Â  metadata: { type: 'help' },
Â  Â  };
Â  }

Â  generateClarification(intentType, needed) {
Â  Â  return {
Â  Â  Â  content: `I understand youâ€™re asking about ${intentType.replace('_', ' ')}, but I need a ${needed} to proceed.`,
Â  Â  Â  metadata: { intent: intentType, needs_clarification: true },
Â  Â  };
Â  }

Â  generateFallbackResponse(_message, intent) {
Â  Â  return {
Â  Â  Â  content:
Â  Â  Â  Â  'I understand what youâ€™re asking, but I need a bit more detail. Can you add specifics (like city, date, or an ID)?',
Â  Â  Â  metadata: { intent: intent.intent_type, needs_clarification: true },
Â  Â  };
Â  }

Â  // ===== Local helpers (new) =====

Â  detectAllPhrase(message) {
Â  Â  const m = String(message || '').toLowerCase();
Â  Â  return /\b(all( of them| shows)?|everything|both|show all)\b/.test(m);
Â  }
}
module.exports = TmAiEngine;
